// src/components/MatchesTab.tsx

import { useState, useEffect, type FC, useRef } from 'react'

import { usePlayers } from '@/context/PlayersContext'
import { useRounds } from '@/context/RoundsContext'
import { generateSchedule } from '@/lib/algorithm'
import type { Player } from '@/types/players'

// shadcn/ui
import { toast } from 'sonner'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Badge } from '@/components/ui/badge'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------
const PLAYERS_PER_MATCH = 4 as const
const STORAGE_KEY_COURTS = 'match_courts'

// -----------------------------------------------------------------------------
// Custom hook: useLocalStorage
// -----------------------------------------------------------------------------
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const stored = localStorage.getItem(key)
    return stored ? (JSON.parse(stored) as T) : initialValue
  })

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value))
  }, [key, value])

  return [value, setValue] as const
}

// -----------------------------------------------------------------------------
// Main component
// -----------------------------------------------------------------------------
const MatchesTab: FC = () => {
  const { players, updatePlayers } = usePlayers()
  const { rounds, addRound, setGames, clear } = useRounds()

  const activePlayers = players.filter((p) => p.active)

  const hasAutoGenerated = useRef(false)

  const [courts, setCourts] = useLocalStorage<number>(STORAGE_KEY_COURTS, 2)
  const [selectedRoundIndex, setSelectedRoundIndex] = useState<number>(rounds.length > 0 ? rounds.length - 1 : 0)

  useEffect(() => {
    if (!hasAutoGenerated.current) {
      hasAutoGenerated.current = true
      // Só gera se ainda não houver nenhuma rodada
      if (rounds.length === 0) {
        handleGenerate()
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  useEffect(() => {
    // ao adicionar/limpar, selecione sempre a última existente
    if (rounds.length === 0) {
      setSelectedRoundIndex(0)
    } else if (selectedRoundIndex > rounds.length - 1) {
      setSelectedRoundIndex(rounds.length - 1)
    }
  }, [rounds, selectedRoundIndex])

  /* --------------------------- Handlers --------------------------- */
  const handleGenerate = () => {
    try {
      const newRound = generateSchedule(activePlayers, courts)
      addRound(newRound)

      updatePlayers((prev) => {
        const updated = prev.map((player) => {
          let addedMatches = 0
          const updatedPartners = { ...player.partnerCounts }

          newRound.matches.forEach(({ teamA, teamB }) => {
            const [a1, a2] = teamA
            if (player.id === a1.id || player.id === a2.id) {
              addedMatches++
              const partnerId = player.id === a1.id ? a2.id : a1.id
              updatedPartners[partnerId] = (updatedPartners[partnerId] || 0) + 1
            }
            const [b1, b2] = teamB
            if (player.id === b1.id || player.id === b2.id) {
              addedMatches++
              const partnerId = player.id === b1.id ? b2.id : b1.id
              updatedPartners[partnerId] = (updatedPartners[partnerId] || 0) + 1
            }
          })

          return {
            ...player,
            matchCount: player.matchCount + addedMatches,
            partnerCounts: updatedPartners,
          }
        })

        return updated
      })

      toast.success('Rodada gerada e estatísticas atualizadas!', {
        description: 'Tudo pronto para a próxima rodada.',
        duration: 3000,
      })
    } catch (error) {
      toast.error((error as Error).message, {
        duration: 6000,
      })
    }
  }

  const handleClear = () => {
    clear()
    updatePlayers((prev) =>
      prev.map((player) => ({
        ...player,
        matchCount: 0,
        partnerCounts: {},
      })),
    )
    toast.success('Todas as rodadas apagadas!', { duration: 3000 })
  }

  /* --------------------------- Score input ------------------------- */
  const ScoreInput: FC<{
    value: number | null
    onChange: (v: number | null) => void
  }> = ({ value, onChange }) => (
    <Input
      type="number"
      min={0}
      className="w-8 text-center"
      value={value ?? ''}
      onChange={(e) => {
        const v = e.target.value
        onChange(v === '' ? null : Number(v))
      }}
    />
  )

  /* ----------------------------- Render ---------------------------- */
  return (
    <Card>
      <CardHeader>
        <CardTitle>Matches</CardTitle>
      </CardHeader>

      <CardContent>
        {/* ------------------------ Controls ----------------------- */}
        <div className="flex flex-wrap items-end gap-4">
          <div className="grid w-32 gap-2">
            <Label htmlFor="courts">Quadras</Label>
            <Input
              id="courts"
              type="number"
              min={1}
              value={courts}
              onChange={(e) => setCourts(Number(e.target.value))}
            />
          </div>

          <Button onClick={handleGenerate} disabled={players.length < PLAYERS_PER_MATCH}>
            Gerar
          </Button>
          <Button variant="secondary" onClick={handleClear} disabled={rounds.length === 0}>
            Limpar
          </Button>
        </div>
        {rounds.length > 0 && (
          <div className="grid gap-2">
            <Select value={String(selectedRoundIndex)} onValueChange={(v) => setSelectedRoundIndex(Number(v))}>
              <SelectTrigger>
                <SelectValue placeholder="Selecione..." />
              </SelectTrigger>
              <SelectContent>
                {rounds.map((_, idx) => (
                  <SelectItem key={idx} value={String(idx)}>
                    Rodada {idx + 1}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        {/* ---------------------- Rounds list ---------------------- */}
        <ScrollArea className="min-h-0 relative flex-1 overflow-hidden" type="scroll">
          <ul className="h-full w-full flex flex-col gap-2">
            {rounds.length === 0 ? (
              <p className="italic text-muted-foreground">Nenhuma rodada gerada ainda.</p>
            ) : (
              (() => {
                const round = rounds[selectedRoundIndex]
                return (
                  <article className="flex flex-col pt-8 flex-1">
                    <h2 className="border-l-4 border-primary pl-3 text-xl font-bold">
                      Rodada {selectedRoundIndex + 1}
                    </h2>
                    <ol className="flex flex-col gap-6 overflow-hidden flex-1">
                      {round.matches.map((m) => (
                        <li
                          key={m.id}
                          className="rounded-2xl border bg-muted px-3 py-4 shadow-sm overflow-hidden flex-1"
                        >
                          {/* Times + placar */}
                          <div className="flex flex-1 items-center gap-4">
                            <TeamView title="Equipe A" players={m.teamA} isWinner={m.winner === 'A'} />
                            <div className="flex flex-col items-center gap-1">
                              <ScoreInput
                                value={m.gamesA}
                                onChange={(v) => setGames(selectedRoundIndex, m.id, 'A', v)}
                              />
                              <span className="font-bold">×</span>
                              <ScoreInput
                                value={m.gamesB}
                                onChange={(v) => setGames(selectedRoundIndex, m.id, 'B', v)}
                              />
                            </div>
                            <TeamView title="Equipe B" players={m.teamB} isWinner={m.winner === 'B'} />
                          </div>
                        </li>
                      ))}
                    </ol>
                  </article>
                )
              })()
            )}
          </ul>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}

// -----------------------------------------------------------------------------
// TeamView sub-component
// -----------------------------------------------------------------------------
interface TeamViewProps {
  title: string
  players: Player[]
  isWinner: boolean
}
const TeamView: FC<TeamViewProps> = ({ title, players, isWinner }) => (
  <div className={`flex flex-1 flex-col gap-2 ${isWinner ? 'ring-2 ring-green-500 rounded-lg p-1' : ''}`}>
    <h3 className="text-lg font-medium opacity-75">{title}</h3>
    <div className="flex flex-col max-w-full">
      {players.map((p) => (
        <div key={p.id} className="flex items-end gap-2 text-base">
          <p>{p.name}</p>
          <Badge variant="outline" className="text-xs">
            Lv {p.level}
          </Badge>
        </div>
      ))}
    </div>
  </div>
)

export default MatchesTab
